[
  {
    "objectID": "outputs/quarto/index.html",
    "href": "outputs/quarto/index.html",
    "title": "Introduction aux rapports reproductibles avec Quarto",
    "section": "",
    "text": "Rapports reproductibles\nUn rapport reproductible vous permet de combiner du format texte avec votre code et leurs sorties (images, animations, tableau). C’est un format très pratique pour mettre au propre vos résultats et accompagner l’utilisateur sur les différentes étapes de mise en place de vos modèle. Ici j’utilise le système Quarto qui est fourni directement à l’installation de RStudio. Vous trouverez plus d’informations sur les fonctions de base de Quarto avec RStudio dans ce tutoriel.\nDans les sections suivantes je reprends les scripts sims_freefallin.R et sims_logKow en format tutoriel pas à pas.\n\n\nConseils d’utilisation\nJ’ai crée un dépôt github ‘template’ que vous pouvez utiliser à votre convenance: rroyaute/gh-template-rr. Vous pouvez créer votre dépot sur la base de ce template en cliquant sur le bouton “Use this template” . Une fois vos analyses termninés, remplissez le document outputs\\quarto\\index.qmd et exportez le vous pouvez les exporter au format voulut (cf. Quarto Authoring pour plus d’information sur l’export de documents).\n\n\nTutoriel 1: Simulations pour un objet en chute libre\nComme vu en cours, la vélosité d’un corps en chute libre avec frottements a une solution analytique de la forme \\(v(t)= \\frac{gm}{c} (1 - e^{-(c/m)t})\\).\n\nExprimer le problème en code\nNous pouvons facilement traduire cette expression en fonction R qui nous retourne une valeure de vélocité pour chaque pas de temps\n\n\nCode\n# Fonction pour chute libre avec frottements\n\nfreefallin_fun = function(g, m, c, t) {\n  v = (g * m)/c * (1 - exp(-c/m*t))\n  return(v)\n}\n\n\nPar exemple, un parachutiste de 80 kg atteindra une vitesse de chute de 50 m/s dès 10 secondes de chute libre\n\n\nCode\n# test\nout = freefallin_fun(g = 9.81, m = 80, c = 12.5, t = 1:10)\nplot(t, out)\n\n\n\n\n\n\n\nSimuler le comportement du modèle\nNous pouvons maintenant interroger le modèle pour comprendre comment la masse du parachutiste influence sa vitesse en chute libre. POur cela, nous allons définir une série de masse corporelle à stocker dans un vecteur et appliquer notre fonction sur chaque élément du vecteur à l’aide de la fonction lapply()\n\n\nCode\n# Importer la fonction\nsource(here(\"R/funs/freefallin_fun.R\"))\n\n# Définir les paramètres\ng = 9.81\nc = 12.5\nt = 1:10\n\n# Parachutiste de 40 à 120 kg\nm_range = c(40:120)\n\n# appliquer la fonction pour chaque valeur de paramètre\n# Stocker chaque vélocité dans liste\nout = lapply(m_range, freefallin_fun, g = g, c = c, t = t)\nout[1:2] # Afficher les 2 premiers éléments de la liste\n\n\n[[1]]\n [1]  8.425122 14.589073 19.098716 22.398041 24.811879 26.577881 27.869915\n [8] 28.815188 29.506764 30.012732\n\n[[2]]\n [1]  8.455636 14.689243 19.284741 22.672603 25.170180 27.011427 28.368818\n [8] 29.369505 30.107225 30.651082\n\n\nNous pouvons ensuite stocker ces informations sous forme de dataframe pour les représenter plus facilement à l’aide de ggplot\n\n\nCode\ndf = data.frame(\n  m = rep(m_range, each = length(t)), # valeur de masse répétée à chaque pas de temps\n  t = rep(t, length(m_range)), # temps répétée pour chaque masse\n  v = unlist(out) # vélositées mises bout à bout\n  )\n\ndf %&gt;% \n  ggplot(aes(x = t, y = v, group = m, color = m)) +\n  geom_point() +\n  geom_line() +\n  scale_color_viridis(option = \"H\") +\n  xlab(\"Temps (s)\") +\n  ylab(\"Vélocité (m/s)\") +\n  theme_bw(16)\n\n\n\n\n\n\n\n\nTutoriel 2: Simulations d’un modèle QSAR\nNous avons également vu comment simuler la relation entre toxicité et lipophilie des contaminants à l’aide d’un modèle QSAR de la forme:\n\\[\ntoxicité = 1 / LC_{50} \\\\\nlog(K_{ow}) \\sim N(\\mu_{Kow}, \\sigma_{Kow}) \\\\\ntoxicité  \\sim N(\\mu_{toxicité}, \\sigma_{toxicité}) \\\\\n\\mu_{toxicité} = \\beta_0 + \\beta_1 log(K_{ow}) \\\\\n\\]\n\nStockage des paramètres\n\n\nCode\nn_compo = 100 # nombre de composés\nb0 = -4 # Ordonnée à l'origine\nb1 = .9 # Pente\nsigma = .25 # variance résiduelle\n\n\nD’après la figure 1 de Könemann 1981, le coefficient de partage des molécules considérées (log(Kow)) peut être approximé par une loi normale d emoyenne 2 et un écart type de 1. Avec la fonction rnorm(), nous pouvons simuler 100 molécules selon cette loi.\n\n\nCode\nlogKow = rnorm(n_compo, 2, 1)  # vecteur de Kow\n\n\nPour simuler l’effet de log(Kow) sur la valeure de toxicité, il suffit d’appliquer la fonction rnorm() à nouveau, cette fois sur le vecteur de valeures de log(Kow) et en appliquant la formule linéaire reliant la toxicité à Kow:\n\n\nCode\nlog_inv_LC50 = rnorm(n_compo, b0 + b1 * logKow, sigma)\n\n\nStockons ces données dans un dataframe pour pouvoir les représenter graphiquement\n\n\nCode\ndf = data.frame( # stockage\n  logKow = logKow,\n  log_inv_LC50 = log_inv_LC50\n) \n\nplot(log_inv_LC50 ~ logKow, df)\n\n\n\n\n\n\n\n\nExporter les tutoriels sous forme de page web\nMaintenant que nous avons fini d’exposer nos simulations et leurs résulats, nous pouvons facilement exporter notre document quarto au format voulu, ici une page html. Pour ce faire, le plus simple est d’utiliser l’incantation quarto render puis git push directement dans le terminal."
  }
]